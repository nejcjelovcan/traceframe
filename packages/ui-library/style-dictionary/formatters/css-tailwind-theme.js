/**
 * Style Dictionary formatter for Tailwind v4 @theme CSS configuration.
 * Generates a CSS file with @theme inline and @theme blocks that define Tailwind utilities.
 *
 * Uses "bridge" variables to avoid circular references in Tailwind v4's @theme inline.
 * Chain: design token (--color-surface) → bridge (--tw-color-surface) → @theme inline → utility class
 */

import { fileHeader } from 'style-dictionary/utils'
import { extractAllTokens } from '../utils/extract-tokens.js'

/**
 * Extracts all tokens from the dictionary into a flat list, including nested tokens.
 * Groups tokens by their category (first path segment).
 * Uses extractAllTokens to recursively discover nested tokens that Style Dictionary
 * v4 doesn't enumerate in dictionary.allTokens.
 */
function extractTokensByCategory(dictionary) {
  const tokensByCategory = {}
  const seen = new Set()

  dictionary.allTokens.forEach((token) => {
    const extracted = extractAllTokens(token)
    extracted.forEach((t) => {
      const pathKey = t.path.join('.')
      if (seen.has(pathKey)) return
      seen.add(pathKey)

      const category = t.path[0]
      if (!tokensByCategory[category]) {
        tokensByCategory[category] = []
      }
      tokensByCategory[category].push(t)
    })
  })

  return tokensByCategory
}

/**
 * Generates CSS variable name from token path.
 * Examples:
 * - ['color', 'surface', 'muted'] -> 'surface-muted'
 * - ['spacing', 'xs'] -> 'xs'
 * - ['fontFamily', 'sans'] -> 'sans'
 * - ['gradient', 'interactive', 'primary'] -> 'interactive-primary'
 */
function generateCssVarName(token) {
  const path = token.path
  const category = path[0]

  if (category === 'color') {
    // For colors, skip the 'color' prefix and use the rest
    return path.slice(1).join('-')
  } else if (category === 'fontFamily' || category === 'fontSize') {
    // For font families and sizes, just use the variant name
    return path.slice(1).join('-')
  } else if (category === 'spacing' || category === 'size' || category === 'borderRadius') {
    // For these, just use the variant name
    return path.slice(1).join('-')
  } else if (category === 'shadow') {
    // For shadows, handle nested structure and DEFAULT keys
    // Handle DEFAULT specially - it becomes the parent name
    const parts = path.slice(1)
    if (parts[parts.length - 1] === 'DEFAULT') {
      return parts.slice(0, -1).join('-')
    }
    return parts.join('-')
  } else if (category === 'gradient') {
    // For gradients, skip the 'gradient' prefix and use the rest
    return path.slice(1).join('-')
  } else if (category === 'borderStyle') {
    // For border styles, use the variant name
    return path.slice(1).join('-')
  }

  // Default: use full path excluding category
  return path.slice(1).join('-')
}

/**
 * Filters tokens to only include semantic tokens (not palette tokens).
 */
function isSemanticToken(token) {
  // Semantic tokens come from the color category but not from palette
  if (token.path[0] === 'color') {
    // Check if it's a semantic color (has nested structure like surface, foreground, etc.)
    const semanticCategories = [
      'surface',
      'foreground',
      'border',
      'ring',
      'interactive',
      'status',
      'disabled',
      'tooltip',
      'accent',
      'shadow',
    ]
    return semanticCategories.includes(token.path[1])
  }
  // Non-color tokens are included
  return true
}

export default function cssTailwindThemeFormatter({ dictionary, options = {}, file }) {
  const { showFileHeader = true } = options

  let output = ''

  // Add file header
  output += '/* Generated by Style Dictionary - do not edit */\n\n'
  output += '/*\n'
  output += ' * Bridge variables: break self-reference cycles in @theme inline.\n'
  output += ' * Tailwind v4 creates CSS custom properties for self-referencing values\n'
  output += ' * (e.g., --color-surface: rgb(var(--color-surface))), causing circular\n'
  output += ' * definitions. These --tw-* bridge variables reference our design tokens,\n'
  output += ' * and @theme inline references the bridges instead.\n'
  output += ' */\n'

  // Extract and categorize tokens
  const tokensByCategory = extractTokensByCategory(dictionary)

  // Build bridge variables and theme inline declarations
  const bridgeLines = []
  const themeLines = []

  // Process semantic colors
  if (tokensByCategory.color) {
    const semanticColors = tokensByCategory.color.filter(isSemanticToken)
    if (semanticColors.length > 0) {
      bridgeLines.push('  /* Colors */')
      themeLines.push('  /* Colors */')
      semanticColors.forEach((token) => {
        const varName = generateCssVarName(token)
        bridgeLines.push(`  --tw-color-${varName}: var(--color-${varName});`)
        themeLines.push(`  --color-${varName}: var(--tw-color-${varName});`)
      })
    }
  }

  // Process spacing
  if (tokensByCategory.spacing) {
    bridgeLines.push('')
    bridgeLines.push('  /* Spacing */')
    themeLines.push('')
    themeLines.push('  /* Spacing */')
    tokensByCategory.spacing.forEach((token) => {
      const varName = generateCssVarName(token)
      bridgeLines.push(`  --tw-spacing-${varName}: var(--spacing-${varName});`)
      themeLines.push(`  --spacing-${varName}: var(--tw-spacing-${varName});`)
    })
  }

  // Process border radius
  if (tokensByCategory.borderRadius) {
    bridgeLines.push('')
    bridgeLines.push('  /* Border radius */')
    themeLines.push('')
    themeLines.push('  /* Border radius */')
    tokensByCategory.borderRadius.forEach((token) => {
      const varName = generateCssVarName(token)
      // Skip DEFAULT (it's just metadata)
      if (varName !== '' && !token.$default) {
        bridgeLines.push(`  --tw-radius-${varName}: var(--radius-${varName});`)
        themeLines.push(`  --radius-${varName}: var(--tw-radius-${varName});`)
      }
    })
  }

  // Process shadows
  if (tokensByCategory.shadow) {
    bridgeLines.push('')
    bridgeLines.push('  /* Shadows */')
    themeLines.push('')
    themeLines.push('  /* Shadows */')
    tokensByCategory.shadow.forEach((token) => {
      const varName = generateCssVarName(token)
      bridgeLines.push(`  --tw-shadow-${varName}: var(--shadow-${varName});`)
      themeLines.push(`  --shadow-${varName}: var(--tw-shadow-${varName});`)
    })
  }

  // Process font families
  if (tokensByCategory.fontFamily) {
    bridgeLines.push('')
    bridgeLines.push('  /* Font families */')
    themeLines.push('')
    themeLines.push('  /* Font families */')
    tokensByCategory.fontFamily.forEach((token) => {
      const varName = generateCssVarName(token)
      bridgeLines.push(`  --tw-font-${varName}: var(--font-${varName});`)
      themeLines.push(`  --font-${varName}: var(--tw-font-${varName});`)
    })
  }

  // Process gradients
  if (tokensByCategory.gradient) {
    bridgeLines.push('')
    bridgeLines.push('  /* Gradients */')
    themeLines.push('')
    themeLines.push('  /* Gradients (map to background-image) */')
    tokensByCategory.gradient.forEach((token) => {
      const varName = generateCssVarName(token)
      bridgeLines.push(`  --tw-gradient-${varName}: var(--gradient-${varName});`)
      // Map to background-image for Tailwind's bg- utility
      themeLines.push(`  --gradient-${varName}: var(--tw-gradient-${varName});`)
    })
  }

  // Process border styles - using bridge pattern
  if (tokensByCategory.borderStyle) {
    bridgeLines.push('')
    bridgeLines.push('  /* Border Styles */')
    themeLines.push('')
    themeLines.push('  /* Border Styles */')
    tokensByCategory.borderStyle.forEach((token) => {
      const varName = generateCssVarName(token)
      bridgeLines.push(`  --tw-border-style-${varName}: var(--border-style-${varName});`)
      themeLines.push(`  --border-style-${varName}: var(--tw-border-style-${varName});`)
    })
  }

  // Process element sizing (both width and height) - no bridge needed
  if (tokensByCategory.size) {
    themeLines.push('')
    themeLines.push('  /* Sizing (width & height) */')
    tokensByCategory.size.forEach((token) => {
      const varName = generateCssVarName(token)
      themeLines.push(`  --width-size-${varName}: var(--size-${varName});`)
      themeLines.push(`  --height-size-${varName}: var(--size-${varName});`)
    })
  }

  // Process font sizes with line heights - no bridge needed
  if (tokensByCategory.fontSize) {
    themeLines.push('')
    themeLines.push('  /* Font sizes */')
    tokensByCategory.fontSize.forEach((token) => {
      const varName = generateCssVarName(token)
      const value = token.value || token.$value
      themeLines.push(`  --font-size-${varName}: ${value};`)

      // Add line height if available
      const lineHeight = token.$lineHeight || token.lineHeight
      if (lineHeight) {
        themeLines.push(`  --font-size-${varName}--line-height: ${lineHeight};`)
      }
    })
  }

  // Add animation declarations
  themeLines.push('')
  themeLines.push('  /* Animations */')
  themeLines.push('  --animate-collapsible-down: collapsible-down 200ms ease-out;')
  themeLines.push('  --animate-collapsible-up: collapsible-up 200ms ease-out;')

  // Assemble the output
  output += ':root {\n'
  output += bridgeLines.join('\n') + '\n'
  output += '}\n\n'

  output += '@theme inline {\n'
  output += themeLines.join('\n') + '\n'
  output += '}\n\n'

  // Add keyframes
  output += '@keyframes collapsible-down {\n'
  output += '  from { height: 0; }\n'
  output += '  to { height: var(--radix-collapsible-content-height); }\n'
  output += '}\n\n'

  output += '@keyframes collapsible-up {\n'
  output += '  from { height: var(--radix-collapsible-content-height); }\n'
  output += '  to { height: 0; }\n'
  output += '}\n'

  return output
}